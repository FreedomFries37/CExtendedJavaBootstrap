ast {
top_level_decs {
  typedef [unsigned long int] {
    id $class_id;
  }
  top_level_decs {
    declarations {
      function_description [std::ClassInfo*] {
        id $__get_class;
        params {
          dec [class_id] {
            id $id;
          }
        }
      }
    }
  }
  typedef [char] {
    id $i8;
  }
  typedef [unsigned char] {
    id $u8;
  }
  typedef [int] {
    id $i16;
  }
  typedef [unsigned int] {
    id $u16;
  }
  typedef [int] {
    id $i32;
  }
  typedef [unsigned int] {
    id $u32;
  }
  typedef [long long int] {
    id $i64;
  }
  typedef [unsigned long long int] {
    id $u64;
  }
  typedef [u32] {
    id $size_t;
  }
  typedef [u8] {
    id $bool;
  }
  qualifiers_and_specifiers [std::String*] {
    class;
    type $String;
  }
  qualifiers_and_specifiers [std::ClassInfo*] {
    class;
    type $ClassInfo;
  }
  qualifiers_and_specifiers [std::Int*] {
    class;
    type $Int;
  }
  declarations {
    function_description [void*] {
      id $calloc;
      params {
        dec [size_t] {
          id $size;
        }
        dec [size_t] {
          id $length;
        }
      }
    }
  }
  declarations {
    function_description [void] {
      id $free;
      params {
        dec [void*] {
          id $ptr;
        }
      }
    }
  }
  declarations {
    function_description [void] {
      id $exit;
      params {
        dec [int] {
          id $status;
        }
      }
    }
  }
  declarations {
    function_description [void] {
      id $panic;
      params {
        dec [std::String*] {
          id $msg;
        }
      }
    }
  }
  declarations {
    function_description [void] {
      id $print;
      params {
        dec [const char*] {
          id $c;
        }
      }
    }
  }
  declarations {
    function_description [void] {
      id $println;
      params {
        dec [const char*] {
          id $c;
        }
      }
    }
  }
  declarations {
    function_description [void] {
      id $print_s;
      params {
        dec [std::String*] {
          id $o;
        }
      }
    }
  }
  declarations {
    function_description [void] {
      id $println_s;
      params {
        dec [std::String*] {
          id $o;
        }
      }
    }
  }
  declarations {
    initialized_declaration {
      dec [void*] {
        id $nullptr;
      }
      cast [void*] {
        literal $0;
      }
    }
  }
  top_level_decs {
    class_definition [std::Object] {
      id $Object;
      class_level_declarations {
        class_level_declaration {
          visibility::@private;
          declarations {
            dec [std::ClassInfo*] {
              id $info;
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          declarations {
            dec [long int] {
              id $references;
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          constructor_definition [std::Object*] {
            type $Object;
            params;
            empty;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [int] {
            virtual;
            id $hashcode;
            params;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [bool] {
            virtual;
            id $equals;
            params {
              dec [std::Object*] {
                id $other;
              }
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [void] {
            virtual;
            id $drop;
            params;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [std::String*] {
            virtual;
            id $toString;
            params;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [std::ClassInfo*] {
            id $getClass;
            params;
          }
        }
      }
      compilation_tag_list {
        compilation_tag {
          id $setAsDefaultInheritance;
          empty;
        }
      }
    }
    class_definition [std::ClassInfo] {
      id $ClassInfo;
      class_level_declarations {
        class_level_declaration {
          visibility::@private;
          declarations {
            dec [std::String*] {
              id $name;
            }
          }
        }
        class_level_declaration {
          visibility::@private;
          declarations {
            dec [std::ClassInfo*] {
              id $parent;
            }
          }
        }
        class_level_declaration {
          visibility::@private;
          declarations {
            dec [i32] {
              id $classHash;
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          constructor_definition [std::ClassInfo*] {
            type $ClassInfo;
            params;
            empty;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [std::String*] {
            id $getName;
            params;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [bool] {
            id $is_object;
            params {
              dec [std::Object] {
                id $o;
              }
            }
          }
        }
        class_level_declaration {
          visibility::@private;
          function_description [bool] {
            id $is_class;
            params {
              dec [std::ClassInfo*] {
                id $o;
              }
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [bool] {
            virtual;
            id $equals;
            params {
              dec [std::Object] {
                id $other;
              }
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [bool] {
            virtual;
            id $equals;
            params {
              dec [std::ClassInfo*] {
                id $other;
              }
            }
          }
        }
      }
    }
    class_definition [std::String] {
      id $String;
      class_level_declarations {
        class_level_declaration {
          visibility::@internal;
          declarations {
            dec [char*] {
              id $backingPtr;
            }
          }
        }
        class_level_declaration {
          visibility::@internal;
          declarations {
            dec [int] {
              id $length;
            }
          }
        }
        class_level_declaration {
          visibility::@internal;
          declarations {
            dec [int] {
              id $cLength;
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          constructor_definition [std::String*] {
            type $String;
            params {
              dec [const char*] {
                id $bp;
              }
            }
            empty;
          }
        }
        class_level_declaration {
          visibility::@public;
          constructor_definition [std::String*] {
            type $String;
            params {
              dec [char] {
                id $c;
              }
            }
            empty;
          }
        }
        class_level_declaration {
          visibility::@public;
          constructor_definition [std::String*] {
            type $String;
            params;
            empty;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [void] {
            virtual;
            id $drop;
            params;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [std::String*] {
            id $concat;
            params {
              dec [std::String*] {
                id $other;
              }
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [std::String*] {
            id $concat;
            params {
              dec [char*] {
                id $other;
              }
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [std::String*] {
            id $concat_integer;
            params {
              dec [long int] {
                id $other;
              }
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [std::String*] {
            id $concat;
            params {
              dec [std::Object] {
                id $other;
              }
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [std::String*] {
            id $concat;
            params {
              dec [char] {
                id $c;
              }
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [char*] {
            id $getCStr;
            params;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [int] {
            virtual;
            id $length;
            params;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [std::String*] {
            virtual;
            id $toString;
            params;
          }
        }
      }
    }
  }
  typedef [long long int] {
    type $i64;
  }
  typedef [unsigned long long int] {
    type $u64;
  }
  typedef [u32] {
    type $size_t;
  }
  typedef [u8] {
    type $bool;
  }
  declarations {
    function_description [char*] {
      id $strcpy;
      params {
        dec [char*] {
          id $destination;
        }
        dec [const char*] {
          id $source;
        }
      }
    }
  }
  declarations {
    function_description [char*] {
      id $strncpy;
      params {
        dec [char*] {
          id $destination;
        }
        dec [const char*] {
          id $source;
        }
        dec [size_t] {
          id $num;
        }
      }
    }
  }
  declarations {
    function_description [char*] {
      id $strcat;
      params {
        dec [char*] {
          id $destination;
        }
        dec [const char*] {
          id $source;
        }
      }
    }
  }
  declarations {
    function_description [char*] {
      id $strncat;
      params {
        dec [char*] {
          id $destination;
        }
        dec [const char*] {
          id $source;
        }
        dec [size_t] {
          id $num;
        }
      }
    }
  }
  declarations {
    function_description [int] {
      id $strcmp;
      params {
        dec [const char*] {
          id $str1;
        }
        dec [const char*] {
          id $str2;
        }
      }
    }
  }
  declarations {
    function_description [int] {
      id $strcoll;
      params {
        dec [const char*] {
          id $str1;
        }
        dec [const char*] {
          id $str2;
        }
      }
    }
  }
  declarations {
    function_description [int] {
      id $strncmp;
      params {
        dec [const char*] {
          id $str1;
        }
        dec [const char*] {
          id $str2;
        }
        dec [size_t] {
          id $num;
        }
      }
    }
  }
  declarations {
    function_description [size_t] {
      id $strxfrm;
      params {
        dec [char*] {
          id $destination;
        }
        dec [const char*] {
          id $source;
        }
        dec [size_t] {
          id $num;
        }
      }
    }
  }
  declarations {
    function_description [char*] {
      id $strdup;
      params {
        dec [const char*] {
          id $str1;
        }
      }
    }
  }
  declarations {
    function_description [size_t] {
      id $strlen;
      params {
        dec [const char*] {
          id $str;
        }
      }
    }
  }
  top_level_decs {
    class_definition [std::Int] {
      id $Int;
      class_level_declarations {
        class_level_declaration {
          visibility::@private;
          declarations {
            dec [int] {
              id $value;
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          constructor_definition [std::Int*] {
            type $Int;
            params {
              dec [int] {
                id $value;
              }
            }
            empty;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [int] {
            id $getValue;
            params;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [void] {
            id $setValue;
            params {
              dec [int] {
                id $value;
              }
            }
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [std::String] {
            virtual;
            id $toString;
            params;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [std::Int*] {
            id $abs;
            params;
          }
        }
        class_level_declaration {
          visibility::@public;
          function_description [std::Int*] {
            id $pow;
            params {
              dec [int] {
                id $exp;
              }
            }
          }
        }
      }
    }
  }
  implement [std::String] {
    constructor_definition [std::String] {
      type $String;
      params;
      id $this;
      sequence {
        string $"";
      }
      compound_statement;
    }
    constructor_definition [std::String] {
      type $String;
      params {
        dec [const char*] {
          id $bp;
        }
      }
      compound_statement {
        assign {
          field_get {
            indirection {
              id $this;
            }
            id $backingPtr;
          }
          assign_type::@=;
          func_call {
            id $strdup;
            sequence {
              id $bp;
            }
          }
        }
        assign {
          field_get {
            indirection {
              id $this;
            }
            id $length;
          }
          assign_type::@=;
          func_call {
            id $strlen;
            sequence {
              id $bp;
            }
          }
        }
        assign {
          field_get {
            indirection {
              id $this;
            }
            id $cLength;
          }
          assign_type::@=;
          binop {
            op::@+;
            field_get {
              indirection {
                id $this;
              }
              id $length;
            }
            literal $1;
          }
        }
      }
    }
    constructor_definition [std::String] {
      type $String;
      params {
        dec [char] {
          id $c;
        }
      }
      compound_statement {
        assign {
          field_get {
            indirection {
              id $this;
            }
            id $backingPtr;
          }
          assign_type::@=;
          func_call {
            id $calloc;
            sequence {
              sizeof [char];
              literal $2;
            }
          }
        }
        assign {
          arr_get {
            field_get {
              indirection {
                id $this;
              }
              id $backingPtr;
            }
            literal $0;
          }
          assign_type::@=;
          id $c;
        }
        assign {
          field_get {
            indirection {
              id $this;
            }
            id $length;
          }
          assign_type::@=;
          literal $1;
        }
        assign {
          field_get {
            indirection {
              id $this;
            }
            id $cLength;
          }
          assign_type::@=;
          binop {
            op::@+;
            field_get {
              indirection {
                id $this;
              }
              id $length;
            }
            literal $1;
          }
        }
      }
    }
    function_definition [void] {
      implementing [std::String] {
        type $String;
      }
      id $drop;
      params;
      compound_statement {
        func_call {
          id $free;
          sequence {
            field_get {
              indirection {
                id $this;
              }
              id $backingPtr;
            }
          }
        }
        method_call {
          indirection {
            super;
          }
          id $drop;
          sequence;
        }
      }
    }
    function_definition [std::String] {
      implementing [std::String] {
        type $String;
      }
      id $concat;
      params {
        dec [std::String] {
          id $other;
        }
      }
      compound_statement {
        declarations {
          dec [char[binop { op::@+; binop { op::@+; field_get { indirection { id $this; } id $length; } field_get { indirection { id $other; } id $length; } } literal $1; }] {
            id $next;
            binop {
              op::@+;
              binop {
                op::@+;
                field_get {
                  indirection {
                    id $this;
                  }
                  id $length;
                }
                field_get {
                  indirection {
                    id $other;
                  }
                  id $length;
                }
              }
              literal $1;
            }
          }
        }
        func_call {
          id $strcpy;
          sequence {
            id $next;
            field_get {
              indirection {
                id $this;
              }
              id $backingPtr;
            }
          }
        }
        func_call {
          id $strcat;
          sequence {
            id $next;
            field_get {
              indirection {
                id $other;
              }
              id $backingPtr;
            }
          }
        }
        return {
          constructor_call::@new [std::String] {
            sequence {
              id $next;
            }
          }
        }
      }
    }
    function_definition [std::String] {
      implementing [std::String] {
        type $String;
      }
      id $concat;
      params {
        dec [std::Object] {
          id $other;
        }
      }
      compound_statement {
        return {
          method_call {
            indirection {
              id $this;
            }
            id $concat;
            sequence {
              method_call {
                indirection {
                  id $other;
                }
                id $toString;
                sequence;
              }
            }
          }
        }
      }
    }
    function_definition [std::String] {
      implementing [std::String] {
        type $String;
      }
      id $concat;
      params {
        dec [char*] {
          id $other;
        }
      }
      compound_statement {
        return {
          method_call {
            indirection {
              id $this;
            }
            id $concat;
            sequence {
              constructor_call::@new [std::String] {
                sequence {
                  id $other;
                }
              }
            }
          }
        }
      }
    }
    function_definition [std::String] {
      implementing [std::String] {
        type $String;
      }
      id $concat;
      params {
        dec [char] {
          id $c;
        }
      }
      compound_statement {
        declarations {
          dec [char[binop { op::@+; field_get { indirection { id $this; } id $cLength; } literal $1; }] {
            id $next;
            binop {
              op::@+;
              field_get {
                indirection {
                  id $this;
                }
                id $cLength;
              }
              literal $1;
            }
          }
        }
        func_call {
          id $strcpy;
          sequence {
            id $next;
            field_get {
              indirection {
                id $this;
              }
              id $backingPtr;
            }
          }
        }
        assign {
          arr_get {
            id $next;
            field_get {
              indirection {
                id $this;
              }
              id $length;
            }
          }
          assign_type::@=;
          id $c;
        }
        assign {
          arr_get {
            id $next;
            binop {
              op::@+;
              field_get {
                indirection {
                  id $this;
                }
                id $length;
              }
              literal $1;
            }
          }
          assign_type::@=;
          cast [char] {
            literal $0;
          }
        }
        return {
          constructor_call::@new [std::String] {
            sequence {
              id $next;
            }
          }
        }
      }
    }
    function_definition [char*] {
      implementing [std::String] {
        type $String;
      }
      id $getCStr;
      params;
      compound_statement {
        return {
          field_get {
            indirection {
              id $this;
            }
            id $backingPtr;
          }
        }
      }
    }
    function_definition [std::String] {
      implementing [std::String] {
        type $String;
      }
      id $concat_integer;
      params {
        dec [long int] {
          id $other;
        }
      }
      compound_statement {
        return {
          id $this;
        }
      }
    }
    function_definition [int] {
      implementing [std::String] {
        type $String;
      }
      id $length;
      params;
      compound_statement {
        return {
          field_get {
            indirection {
              id $this;
            }
            id $length;
          }
        }
      }
    }
    function_definition [std::String] {
      implementing [std::String] {
        type $String;
      }
      id $toString;
      params;
      compound_statement {
        return {
          id $this;
        }
      }
    }
  }
  function_definition [char*] {
    empty;
    id $strdup;
    params {
      dec [const char*] {
        id $str1;
      }
    }
    compound_statement {
      declarations {
        initialized_declaration {
          dec [size_t] {
            id $length;
          }
          func_call {
            id $strlen;
            sequence {
              id $str1;
            }
          }
        }
      }
      declarations {
        initialized_declaration {
          dec [char*] {
            id $output;
          }
          func_call {
            id $calloc;
            sequence {
              sizeof [char];
              binop {
                op::@+;
                id $length;
                literal $1;
              }
            }
          }
        }
      }
      for {
        declarations {
          initialized_declaration {
            dec [int] {
              id $i;
            }
            literal $0;
          }
        }
        binop {
          op::@<;
          id $i;
          id $length;
        }
        uniop {
          op::@++;
          id $i;
        }
        compound_statement {
          assign {
            arr_get {
              id $output;
              id $i;
            }
            assign_type::@=;
            arr_get {
              id $str1;
              id $i;
            }
          }
        }
      }
      return {
        id $output;
      }
    }
  }
  function_definition [size_t] {
    empty;
    id $strlen;
    params {
      dec [const char*] {
        id $str;
      }
    }
    compound_statement {
      declarations {
        initialized_declaration {
          dec [char*] {
            id $ptr;
          }
          id $str;
        }
      }
      declarations {
        initialized_declaration {
          dec [size_t] {
            id $output;
          }
          literal $0;
        }
      }
      while {
        binop {
          op::@!=;
          indirection {
            id $ptr;
          }
          literal $0;
        }
        compound_statement {
          uniop {
            op::@++;
            id $ptr;
          }
          uniop {
            op::@++;
            id $output;
          }
        }
      }
      return {
        id $output;
      }
    }
  }
  function_definition [char*] {
    empty;
    id $strcpy;
    params {
      dec [char*] {
        id $destination;
      }
      dec [const char*] {
        id $source;
      }
    }
    compound_statement {
      declarations {
        initialized_declaration {
          dec [size_t] {
            id $length;
          }
          func_call {
            id $strlen;
            sequence {
              id $source;
            }
          }
        }
      }
      for {
        declarations {
          initialized_declaration {
            dec [int] {
              id $i;
            }
            literal $0;
          }
        }
        binop {
          op::@<;
          id $i;
          id $length;
        }
        uniop {
          op::@++;
          id $i;
        }
        compound_statement {
          assign {
            arr_get {
              id $destination;
              id $i;
            }
            assign_type::@=;
            arr_get {
              id $source;
              id $i;
            }
          }
        }
      }
      return {
        id $destination;
      }
    }
  }
  function_definition [char*] {
    empty;
    id $strncpy;
    params {
      dec [char*] {
        id $destination;
      }
      dec [const char*] {
        id $source;
      }
      dec [size_t] {
        id $num;
      }
    }
    compound_statement {
      for {
        declarations {
          initialized_declaration {
            dec [int] {
              id $i;
            }
            literal $0;
          }
        }
        binop {
          op::@<;
          id $i;
          id $num;
        }
        uniop {
          op::@++;
          id $i;
        }
        compound_statement {
          assign {
            arr_get {
              id $destination;
              id $i;
            }
            assign_type::@=;
            arr_get {
              id $source;
              id $i;
            }
          }
        }
      }
      return {
        id $destination;
      }
    }
  }
  function_definition [char*] {
    empty;
    id $strcat;
    params {
      dec [char*] {
        id $destination;
      }
      dec [const char*] {
        id $source;
      }
    }
    compound_statement {
      declarations {
        initialized_declaration {
          dec [size_t] {
            id $dest;
          }
          func_call {
            id $strlen;
            sequence {
              id $destination;
            }
          }
        }
      }
      declarations {
        initialized_declaration {
          dec [size_t] {
            id $src;
          }
          func_call {
            id $strlen;
            sequence {
              id $source;
            }
          }
        }
      }
      for {
        declarations {
          initialized_declaration {
            dec [int] {
              id $i;
            }
            literal $0;
          }
        }
        binop {
          op::@<;
          id $i;
          id $src;
        }
        uniop {
          op::@++;
          id $i;
        }
        compound_statement {
          assign {
            arr_get {
              id $destination;
              binop {
                op::@+;
                id $dest;
                id $i;
              }
            }
            assign_type::@=;
            arr_get {
              id $source;
              id $i;
            }
          }
        }
      }
      assign {
        arr_get {
          id $destination;
          binop {
            op::@+;
            id $dest;
            id $src;
          }
        }
        assign_type::@=;
        literal $0;
      }
      return {
        id $destination;
      }
    }
  }
  declarations {
    function_description [char*] {
      id $strncat;
      params {
        dec [char*] {
          id $destination;
        }
        dec [const char*] {
          id $source;
        }
        dec [size_t] {
          id $num;
        }
      }
    }
  }
  function_definition [int] {
    empty;
    id $strcmp;
    params {
      dec [const char*] {
        id $str1;
      }
      dec [const char*] {
        id $str2;
      }
    }
    compound_statement {
      declarations {
        dec [char*] {
          id $ptr1;
        }
        dec [char*] {
          id $ptr2;
        }
      }
      while {
        binop {
          op::@||;
          binop {
            op::@!=;
            id $ptr1;
            id $nullptr;
          }
          binop {
            op::@!=;
            id $ptr2;
            id $nullptr;
          }
        }
        compound_statement {
          if {
            binop {
              op::@<;
              indirection {
                id $ptr1;
              }
              indirection {
                id $ptr2;
              }
            }
            compound_statement {
              return {
                uniop {
                  op::@-;
                  literal $1;
                }
              }
            }
            if {
              binop {
                op::@>;
                indirection {
                  id $ptr1;
                }
                indirection {
                  id $ptr2;
                }
              }
              compound_statement {
                return {
                  literal $1;
                }
              }
              empty;
            }
          }
        }
      }
      return {
        literal $0;
      }
    }
  }
  declarations {
    function_description [int] {
      id $strcoll;
      params {
        dec [const char*] {
          id $str1;
        }
        dec [const char*] {
          id $str2;
        }
      }
    }
  }
  declarations {
    function_description [int] {
      id $strncmp;
      params {
        dec [const char*] {
          id $str1;
        }
        dec [const char*] {
          id $str2;
        }
        dec [size_t] {
          id $num;
        }
      }
    }
  }
  declarations {
    function_description [size_t] {
      id $strxfrm;
      params {
        dec [char*] {
          id $destination;
        }
        dec [const char*] {
          id $source;
        }
        dec [size_t] {
          id $num;
        }
      }
    }
  }
}
}
